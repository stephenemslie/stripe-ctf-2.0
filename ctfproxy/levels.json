[
    {
        "emoji": "\ud83d\udd10",
        "index": 0,
        "name": "The Secret Safe",
        "sources": [
            {
                "language": "html",
                "level": 0,
                "name": "level00.html",
                "content": "<html>\n  <head>\n    <title>Secret Safe</title>\n  </head>\n  <body>\n    {{#namespace}}\n    <div style=\"border-width: 2px; border-style: outset; padding: 5px\">\n      Showing secrets for <strong>{{namespace}}</strong>:\n      <table>\n        <thead>\n          <tr>\n            <th>Key</th>\n            <th>Value</th>\n          </tr>\n        </thead>\n        <tbody>\n          {{#secrets}}\n          <tr>\n            <td>{{ key }}</td>\n            <td>{{ secret }}</td>\n          </tr>\n          {{/secrets}}\n          {{^secrets}}\n          <tr>\n            <td span=\"2\">\n              You have no secrets stored with us. Try using the form below.\n            </td>\n          </tr>\n          {{/secrets}}\n        </tbody>\n      </table>\n\n      <hr />\n    </div>\n    {{/namespace}}\n\n    <form action=\"\" method=\"POST\">\n      <p>\n        <label for=\"namespace\">Namespace:</label>\n        <input type=\"text\" name=\"namespace\" id=\"namespace\"\n            value=\"{{ namespace }}\" />\n      </p>\n      <p>\n        <label for=\"secret_name\">Name of your secret:</label>\n        <input type=\"text\" name=\"secret_name\" id=\"secret_name\">\n      </p>\n      <p>\n        <label for=\"secret_value\">Your secret:</label>\n        <input type=\"password\" name=\"secret_value\" id=\"secret_value\">\n      </p>\n      <p>\n        <input type=\"submit\" value=\"Store my secret!\" />\n      </p>\n    </form>\n    <form action=\"\" method=\"GET\">\n      <label for=\"change_namespace\">\n        Want to retrieve your secrets? View secrets for:\n      </label>\n      <input name=\"namespace\" id=\"change_namespace\" />\n      <input type=\"submit\" value=\"View\" />\n    </form>\n  </body>\n</html>\n"
            },
            {
                "language": "javascript",
                "level": 0,
                "name": "level00.js",
                "content": "var path = require(\"path\");\n\nvar express = require(\"express\"), // Web framework\n  mu = require(\"mu2\"), // Mustache.js templating\n  sqlite3 = require(\"sqlite3\"), // SQLite (database) driver\n  bodyParser = require(\"body-parser\"); // Body parsing middleware\n\n// Look for templates in the current directory\nmu.root = __dirname;\n\n// Set up the DB\nvar db = new sqlite3.Database(path.join(__dirname, \"level00.db\"));\ndb.run(\n  \"CREATE TABLE IF NOT EXISTS secrets (\" +\n    \"key varchar(255),\" +\n    \"secret varchar(255)\" +\n    \")\"\n);\n\n// Create the server\nvar app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nfunction renderPage(res, variables) {\n  var stream = mu.compileAndRender(\n    path.join(__dirname, \"level00.html\"),\n    variables\n  );\n  res.header(\"Content-Type\", \"text/html\");\n  stream.pipe(res);\n}\n\napp.get(\"/*\", function(req, res) {\n  var namespace = req.param(\"namespace\");\n\n  if (namespace) {\n    var query = 'SELECT * FROM secrets WHERE key LIKE ? || \".%\"';\n    db.all(query, namespace, function(err, secrets) {\n      if (err) throw err;\n\n      renderPage(res, { namespace: namespace, secrets: secrets });\n    });\n  } else {\n    renderPage(res, {});\n  }\n});\n\napp.post(\"/*\", function(req, res) {\n  var namespace = req.body[\"namespace\"];\n  var secret_name = req.body[\"secret_name\"];\n  var secret_value = req.body[\"secret_value\"];\n\n  var query = 'INSERT INTO secrets (key, secret) VALUES (? || \".\" || ?, ?)';\n  db.run(query, namespace, secret_name, secret_value, function(err) {\n    if (err) throw err;\n\n    res.header(\"Content-Type\", \"text/html\");\n    res.redirect(req.path + \"?namespace=\" + namespace);\n  });\n});\n\nif (process.argv.length > 2) {\n  var socket = process.argv[2];\n  console.log(\"Starting server on UNIX socket \" + socket);\n  app.listen(socket);\n} else {\n  var port = parseInt(process.env.PORT || \"3000\");\n  console.log(`Starting server on port ${port}`);\n  app.listen(port);\n}\n"
            }
        ]
    },
    {
        "emoji": "\ud83c\udfb2",
        "index": 1,
        "name": "The Guessing Game",
        "sources": [
            {
                "language": "php",
                "level": 1,
                "name": "index.php",
                "content": "<html>\n  <head>\n    <title>Guessing Game</title>\n  </head>\n  <body>\n    <h1>Welcome to the Guessing Game!</h1>\n    <p>\n      Guess the secret combination below, and if you get it right,\n      you'll get the password to the next level!\n    </p>\n    <?php\n      $filename = 'secret-combination.txt';\n      extract($_GET);\n      if (isset($attempt)) {\n        $combination = trim(file_get_contents($filename));\n        if ($attempt === $combination) {\n          echo \"<p>How did you know the secret combination was\" .\n               \" $combination!?</p>\";\n          $next = $_ENV[\"LEVEL1_PW\"];\n          echo \"<p>You've earned the password to the access Level 2:\" .\n               \" $next</p>\";\n        } else {\n          echo \"<p>Incorrect! The secret combination is not $attempt</p>\";\n        }\n      }\n    ?>\n    <form action=\"/index.php\" method=\"GET\">\n      <p><input type=\"text\" name=\"attempt\"></p>\n      <p><input type=\"submit\" value=\"Guess!\"></p>\n    </form>\n  </body>\n</html>\n"
            },
            {
                "language": "php",
                "level": 1,
                "name": "routing.php",
                "content": "<?php\n\n$forbid = [\n  '/^\\/level02-password.txt/',\n  '/^\\/secret-combination.txt/'\n];\n\nif (\n  file_exists($_SERVER['SCRIPT_FILENAME']) &&\n  # Make sure we're not letting people read secrets directly.\n  !current(array_filter($forbid, function($element) { return preg_match($element, $_SERVER['PHP_SELF']); }))\n) {\n  // Serve the requested resource as-is.\n  return false;\n} else {\n  include_once 'index.php';\n}\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\udc65",
        "index": 2,
        "name": "The Social Network",
        "sources": [
            {
                "language": "php",
                "level": 2,
                "name": "index.php",
                "content": "<?php\n  session_start();\n\n  if ($_FILES[\"dispic\"][\"error\"] > 0) {\n    echo \"<p>Error: \" . $_FILES[\"dispic\"][\"error\"] . \"</p>\";\n  }\n  else\n  {\n    $dest_dir = \"uploads/\";\n    $dest = $dest_dir . basename($_FILES[\"dispic\"][\"name\"]);\n    $src = $_FILES[\"dispic\"][\"tmp_name\"];\n    if (move_uploaded_file($src, $dest)) {\n      $_SESSION[\"dispic_url\"] = $dest;\n      chmod($dest, 0644);\n      echo \"<p>Successfully uploaded your display picture.</p>\";\n    }\n  }\n\n  $url = \"https://upload.wikimedia.org/wikipedia/commons/f/f8/\" .\n         \"Question_mark_alternate.svg\";\n  if (isset($_SESSION[\"dispic_url\"])) {\n    $url = $_SESSION[\"dispic_url\"];\n  }\n\n?>\n\n<html>\n  <head>\n    <title>Welcome to the CTF!</title>\n  </head>\n  <body>\n    <center>\n      <h1>Welcome to the CTF Social Network!</h1>\n      <div>\n        <img src=<?php echo $url; ?> />\n        <?php\n          if (!isset($_SESSION[\"dispic_url\"])) {\n            echo \"<p>Oh, looks like you don't have a profile image\" .\n                 \" -- upload one now!</p>\";\n          }\n        ?>\n        <form action=\"/index.php\" method=\"post\" enctype=\"multipart/form-data\">\n          <input type=\"file\" name=\"dispic\" size=\"40\" />\n          <input type=\"submit\" value=\"Upload!\">\n        </form>\n\n        <p>\n           Password for Level 3 (accessible only to members of the club):\n           <a href=\"password.txt\">password.txt</a>\n        </p>\n      </div>\n    </center>\n  </body>\n</html>\n"
            },
            {
                "language": "php",
                "level": 2,
                "name": "routing.php",
                "content": "<?php\n\n$forbid = [\n  '/^\\/password.txt/'\n];\n\nif (\n  file_exists($_SERVER['SCRIPT_FILENAME']) &&\n  # Make sure we're not letting people read secrets directly.\n  !current(array_filter($forbid, function($element) { return preg_match($element, $_SERVER['PHP_SELF']); }))\n) {\n  // Serve the requested resource as-is.\n  return false;\n} else {\n  include_once 'index.php';\n}\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\ude4a",
        "index": 3,
        "name": "The Secret Vault",
        "sources": [
            {
                "language": "html",
                "level": 3,
                "name": "index.html",
                "content": "<html>\n  <body>\n    <p>\n      Welcome to the Secret Safe, a place to guard your most\n      precious secrets! To retrieve your secrets, log in below.\n    </p>\n\n    <p>The current users of the system store the following secrets:</p>\n\n    <ul>\n      <li>bob: Stores the password to access level 04</li>\n      <li>eve: Stores the proof that P = NP </li>\n      <li>mallory: Stores the plans to a perpetual motion machine </li>\n    </ul>\n\n    <p>\n      You should use it too!\n      <a href=\"http://www.youtube.com/watch?v=oHg5SJYRHA0\">Contact us</a>\n      to request a beta invite.\n    </p>\n\n    <form method=\"POST\" action=\"./login\">\n      <p>\n        <label for=\"username\">Username:</label>\n        <input type=\"text\" name=\"username\" id=\"username\">\n      </p>\n      <p>\n        <label for=\"password\">Password:</label>\n        <input type=\"password\" name=\"password\" id=\"password\">\n      </p>\n      <input type=\"submit\" value=\"Recover your secrets now!\">\n    </form>\n  </body>\n</html>\n"
            },
            {
                "language": "python",
                "level": 3,
                "name": "secretvault.py",
                "content": "#!/usr/bin/env python\n#\n# Welcome to the Secret Safe!\n#\n# - users/users.db stores authentication info with the schema:\n#\n# CREATE TABLE users (\n#   id VARCHAR(255) PRIMARY KEY AUTOINCREMENT,\n#   username VARCHAR(255),\n#   password_hash VARCHAR(255),\n#   salt VARCHAR(255)\n# );\n#\n# - For extra security, the dictionary of secrets lives\n#   data/secrets.json (so a compromise of the database won't\n#   compromise the secrets themselves)\n\nimport flask\nimport hashlib\nimport json\nimport logging\nimport os\nimport sqlite3\nimport subprocess\nimport sys\nfrom werkzeug import debug\n\n# Generate test data when running locally\ndata_dir = os.environ['DATA_DIR']\nif not os.path.exists(data_dir):\n    import generate_data\n    os.mkdir(data_dir)\n    generate_data.main(data_dir, 'dummy-password', 'dummy-proof', 'dummy-plans')\n\nsecrets = json.load(open(os.path.join(data_dir, 'secrets.json')))\nindex_html = open('index.html').read()\napp = flask.Flask(__name__)\n\n# Turn on backtraces, but turn off code execution (that'd be an easy level!)\napp.config['PROPAGATE_EXCEPTIONS'] = True\napp.wsgi_app = debug.DebuggedApplication(app.wsgi_app, evalex=False)\n\napp.logger.addHandler(logging.StreamHandler(sys.stderr))\n# use persistent entropy file for secret_key\napp.secret_key = open(os.path.join(data_dir, 'entropy.dat'), 'rb').read()\n\n@app.route('/')\ndef index():\n    try:\n        user_id = flask.session['user_id']\n    except KeyError:\n        return index_html\n    else:\n        secret = secrets[str(user_id)]\n        return (u'Welcome back! Your secret is: \"{0}\"'.format(secret) +\n                u' (<a href=\"./logout\">Log out</a>)\\n')\n\n@app.route('/logout')\ndef logout():\n    flask.session.pop('user_id', None)\n    return flask.redirect('/')\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = flask.request.form.get('username')\n    password = flask.request.form.get('password')\n\n    if not username:\n        return \"Must provide username\\n\"\n\n    if not password:\n        return \"Must provide password\\n\"\n\n    conn = sqlite3.connect(os.path.join(data_dir, 'users.db'))\n    cursor = conn.cursor()\n\n    query = \"\"\"SELECT id, password_hash, salt FROM users\n               WHERE username = '{0}' LIMIT 1\"\"\".format(username)\n    cursor.execute(query)\n\n    res = cursor.fetchone()\n    if not res:\n        return \"There's no such user {0}!\\n\".format(username)\n    user_id, password_hash, salt = res\n\n    calculated_hash = hashlib.sha256((password + salt).encode('utf-8'))\n    if calculated_hash.hexdigest() != password_hash:\n        return \"That's not the password for {0}!\\n\".format(username)\n\n    flask.session['user_id'] = user_id\n    return flask.redirect('/')\n\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', 5000))\n    app.run(host='0.0.0.0', port=port)\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\ude4f",
        "index": 4,
        "name": "Karma Trader",
        "port": 4567,
        "sources": [
            {
                "language": "ruby",
                "level": 4,
                "name": "server/srv.rb",
                "content": "#!/usr/bin/env ruby\nrequire 'yaml'\nrequire 'set'\n\nrequire 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'sequel'\nrequire 'sinatra'\n\nmodule KarmaTrader\n  PASSWORD = ENV['LEVEL4_PW'].strip\n  STARTING_KARMA = 500\n  KARMA_FOUNTAIN = 'karma_fountain'\n\n  module DB\n    def self.db_file\n      'karma.db'\n    end\n\n    def self.conn\n      @conn ||= Sequel.sqlite(db_file)\n    end\n\n    def self.init\n      return if File.exists?(db_file)\n      File.umask(0066)\n\n      conn.create_table(:users) do\n        primary_key :id\n        String :username\n        String :password\n        Integer :karma\n        Time :last_active\n      end\n\n      conn.create_table(:transfers) do\n        primary_id :id\n        String :from\n        String :to\n        Integer :amount\n      end\n\n      # Karma Fountain has infinite karma, so just set it to -1\n      conn[:users].insert(\n        :username => KarmaTrader::KARMA_FOUNTAIN,\n        :password => KarmaTrader::PASSWORD,\n        :karma => -1,\n        :last_active => Time.now.utc\n        )\n    end\n  end\n\n  class KarmaSrv < Sinatra::Base\n    set :environment, :production\n    set :port, Integer(ENV['PORT'] || 4567)\n    enable :sessions\n\n    # Use persistent entropy file\n    entropy_file = 'entropy.dat'\n    unless File.exists?(entropy_file)\n      File.open(entropy_file, 'w') do |f|\n        f.write(OpenSSL::Random.random_bytes(24))\n      end\n    end\n    set :session_secret, File.read(entropy_file)\n\n    def die(msg, view)\n      @error = msg\n      halt(erb(view))\n    end\n\n    before do\n      refresh_state\n      update_last_active\n    end\n\n    def refresh_state\n      @user = logged_in_user\n      @transfers = transfers_for_user\n      @trusts_me = trusts_me\n      @registered_users = registered_users\n    end\n\n    def update_last_active\n      return unless @user\n      DB.conn[:users].where(:username => @user[:username]).\n        update(:last_active => Time.now.utc)\n    end\n\n    def logged_in_user\n      return unless username = session[:user]\n      DB.conn[:users][:username => username]\n    end\n\n    def transfers_for_user\n      return [] unless @user\n\n      DB.conn[:transfers].where(\n        Sequel.or(:from => @user[:username], :to => @user[:username])\n        )\n    end\n\n    def trusts_me\n      trusts_me = Set.new\n      return trusts_me unless @user\n\n      # Get all the users who have transferred credits to me\n      DB.conn[:transfers].where(:to => @user[:username]).\n        join(:users, :username => :from).each do |result|\n        trusts_me.add(result[:username])\n      end\n\n      trusts_me\n    end\n\n    def registered_users\n      KarmaTrader::DB.conn[:users].reverse_order(:id)\n    end\n\n    # KARMA_FOUNTAIN gets all the karma it wants. (Part of why getting\n    # its password would be so great...)\n    def user_has_infinite_karma?\n      @user[:username] == KARMA_FOUNTAIN\n    end\n\n    get '/' do\n      if @user\n        erb :home\n      else\n        erb :login\n      end\n    end\n\n    get '/register' do\n      erb :register\n    end\n\n    post '/register' do\n      username = params[:username]\n      password = params[:password]\n      unless username && password\n        die(\"Please specify both a username and a password.\", :register)\n      end\n\n      unless username =~ /^\\w+$/\n        die(\"Invalid username. Usernames must match /^\\w+$/\", :register)\n      end\n\n      unless DB.conn[:users].where(:username => username).count == 0\n        die(\"This username is already registered. Try another one.\",\n            :register)\n      end\n\n      DB.conn[:users].insert(\n        :username => username,\n        :password => password,\n        :karma => STARTING_KARMA,\n        :last_active => Time.now.utc\n      )\n      session[:user] = username\n      redirect '/'\n    end\n\n    get '/login' do\n      redirect '/'\n    end\n\n    post '/login' do\n      username = params[:username]\n      password = params[:password]\n      user = DB.conn[:users][:username => username, :password => password]\n      unless user\n        die('Could not authenticate. Perhaps you meant to register a new' \\\n            ' account? (See link below.)', :login)\n      end\n\n      session[:user] = user[:username]\n      redirect '/'\n    end\n\n    get '/transfer' do\n      redirect '/'\n    end\n\n    post '/transfer' do\n      redirect '/' unless @user\n\n      from = @user[:username]\n      to = params[:to]\n      amount = params[:amount]\n\n      die(\"Please fill out all the fields.\", :home) unless amount && to\n      amount = amount.to_i\n      die(\"Invalid amount specified.\", :home) if amount <= 0\n      die(\"You cannot send yourself karma!\", :home) if to == from\n      unless DB.conn[:users][:username => to]\n        die(\"No user with username #{to.inspect} found.\", :home)\n      end\n\n      unless user_has_infinite_karma?\n        if @user[:karma] < amount\n          die(\"You only have #{@user[:karma]} karma left.\", :home)\n        end\n      end\n\n      DB.conn[:transfers].insert(:from => from, :to => to, :amount => amount)\n      to_user = DB.conn[:users][:username => to]\n      from_user = DB.conn[:users][:username => from]\n      DB.conn[:users].where(:username => from).update(:karma => from_user[:karma].to_i - amount)\n      DB.conn[:users].where(:username => to).update(:karma => to_user[:karma].to_i + amount)\n\n      refresh_state\n      @success = \"You successfully transfered #{amount} karma to #{to.inspect}.\"\n      erb :home\n    end\n\n    get '/logout' do\n      session.clear\n      redirect '/'\n    end\n  end\nend\n\ndef main\n  KarmaTrader::DB.init\n  KarmaTrader::KarmaSrv.run!\nend\n\nif $0 == __FILE__\n  main\n  exit(0)\nend\n"
            },
            {
                "language": "ruby",
                "level": 4,
                "name": "server/views/layout.erb",
                "content": "<!doctype html>\n<html>\n  <head>\n    <title>Karma Trader</title>\n    <script type=\"text/javascript\"\n            src=\"/js/jquery-1.8.0.min.js\"></script>\n  </head>\n  <body>\n<% if @error %>\n  <p>Error: <%= @error %></p>\n<% end %>\n<% if @success %>\n  <p>Success: <%= @success %></p>\n<% end %>\n\n<%= yield %>\n  </body>\n</html>\n"
            },
            {
                "language": "ruby",
                "level": 4,
                "name": "server/views/home.erb",
                "content": "<h1>Welcome to Karma Trader!</h1>\n\n<h3>Home</h3>\n<p>You are logged in as <%= @user[:username] %>.</p>\n\n<h3>Transfer karma</h3>\n<p>\n  You have <%= @user[:karma] %> karma at the moment. Transfer\n  karma to people who have done good deeds and you think will keep\n  doing good deeds in the future.\n</p>\n\n<p>\n  Note that transferring karma to someone will reveal your\n  password to them, which will hopefully incentivize you to only\n  give karma to people you really trust.\n</p>\n\n<p>\n  If you're anything like <strong>karma_fountain</strong>, you'll find\n  yourself logging in every minute to see what new and exciting\n  developments are afoot on the platform. (Though no need to be as paranoid as\n  <strong>karma_fountain</strong> and firewall your outbound network connections\n  so you can only make connections to the Karma Trader server itself.)\n</p>\n\n<p>See below for a list of all registered usernames.</p>\n<form action=\"/transfer\" method=\"POST\">\n  <p>To: <input type=\"to\" name=\"to\" /></p>\n  <p>Amount of karma: <input type=\"text\" name=\"amount\" /></p>\n  <p><input type=\"submit\" value=\"Submit\" /></p>\n</form>\n\n<h3>Past transfers</h3>\n<table border=\"1\">\n  <tr>\n    <th>From</th>\n    <th>To</th>\n    <th>Amount</th>\n  </tr>\n  <% @transfers.each do |transfer| %>\n  <tr>\n    <td><%= transfer[:from] %></td>\n    <td><%= transfer[:to] %></td>\n    <td><%= transfer[:amount] %></td>\n  </tr>\n  <% end %>\n</table>\n\n<h3> Registered Users </h3>\n<ul>\n  <% @registered_users.each do |user| %>\n  <% last_active = user[:last_active].strftime('%H:%M:%S UTC') %>\n  <% if @trusts_me.include?(user[:username]) %>\n  <li>\n    <%= user[:username] %>\n    (password: <%= user[:password] %>, last active <%= last_active %>)\n  </li>\n  <% elsif user[:username] == @user[:username] %>\n  <li>\n    <%= user[:username] %>\n    (<strong>you</strong>, last active <%= last_active %>)\n  </li>\n  <% else %>\n  <li>\n    <%= user[:username] %>\n    (password: <i>[hasn't yet transferred karma to you]</i>,\n    last active <%= last_active %>)\n  </li>\n  <% end %>\n  <% end %>\n</ul>\n\n<p><a href=\"/logout\">Log out</a></p>\n"
            },
            {
                "language": "ruby",
                "level": 4,
                "name": "server/views/login.erb",
                "content": "<h1>\n  Welcome to Karma Trader, the best way to reward people for good deeds!\n</h1>\n\n<h3>Login</h3>\n\n<form action=\"/login\" method=\"POST\">\n  <p>Username: <input type=\"text\" name=\"username\" /></p>\n  <p>Password: <input type=\"password\" name=\"password\" /></p>\n  <p><input type=\"submit\" value=\"Log in\" /></p>\n</form>\n\n<p>\n  Don't have an account?\n  <a href=\"/register\">Register</a> now!\n</p>\n"
            },
            {
                "language": "ruby",
                "level": 4,
                "name": "server/views/register.erb",
                "content": "<h1>Welcome to Karma Trader, the best way to reward people for good deeds!</h1>\n\n<h3>Register</h3>\n\n<form action=\"/register\" method=\"POST\">\n  <p>Pick your username: <input type=\"text\" name=\"username\" /></p>\n  <p>Choose a password: <input type=\"password\" name=\"password\" /></p>\n  <p><input type=\"submit\" value=\"Create account\" /></p>\n</form>\n\n<p>Already have an account? <a href=\"/\">Log in</a> now!</p>\n"
            }
        ]
    },
    {
        "emoji": "\ud83c\udf10",
        "index": 5,
        "name": "DomainAuthenticator",
        "port": 4567,
        "sources": [
            {
                "language": "ruby",
                "level": 5,
                "name": "srv.rb",
                "content": "#!/usr/bin/env ruby\nrequire 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'logger'\nrequire 'uri'\n\nrequire 'restclient'\nrequire 'sinatra'\n\n$log = Logger.new(STDERR)\n$log.level = Logger::INFO\n\nmodule DomainAuthenticator\n  class DomainAuthenticatorSrv < Sinatra::Base\n    set :environment, :production\n    set :port, Integer(ENV['PORT'] || 4567)\n\n    # If authenticated for localhost, share the password.\n    PASSWORD_HOSTS = /^(localhost|level5.hack2012.app)$/\n    # Let people try to authenticate for any host.\n    ALLOWED_HOSTS = //\n\n    PASSWORD = ENV['LEVEL5_PW'].strip\n    enable :sessions\n\n    # Use persistent entropy file\n    entropy_file = 'entropy.dat'\n    unless File.exists?(entropy_file)\n      File.open(entropy_file, 'w') do |f|\n        f.write(OpenSSL::Random.random_bytes(24))\n      end\n    end\n    set :session_secret, File.read(entropy_file)\n\n    get '/*' do\n      output = <<EOF\n<p>\n  Welcome to the Domain Authenticator. Please authenticate as a user from\n  your domain of choice.\n</p>\n\n<form action=\"\" method=\"POST\">\n<p>Pingback URL: <input type=\"text\" name=\"pingback\" /></p>\n<p>Username: <input type=\"text\" name=\"username\" /></p>\n<p>Password: <input type=\"password\" name=\"password\" /></p>\n<p><input type=\"submit\" value=\"Submit\"></p>\n</form>\nEOF\n\n      user = session[:auth_user]\n      host = session[:auth_host]\n      if user && host\n        output += \"<p> You are authenticated as #{user}@#{host}. </p>\"\n        if host =~ PASSWORD_HOSTS\n          output += \"<p> Since you're a user of a password host and all,\"\n          output += \" you deserve to know this password: #{PASSWORD} </p>\"\n        end\n      end\n\n      output\n    end\n\n    post '/*' do\n      pingback = params[:pingback]\n      username = params[:username]\n      password = params[:password]\n\n      pingback = \"http://#{pingback}\" unless pingback.include?('://')\n\n      host = URI.parse(pingback).host\n      unless host =~ ALLOWED_HOSTS\n        return \"Host not allowed: #{host}\" \\\n               \" (allowed authentication hosts are #{ALLOWED_HOSTS.inspect})\"\n      end\n\n      begin\n        body = perform_authenticate(pingback, username, password)\n      rescue StandardError => e\n        return \"An unknown error occurred while requesting #{pingback}: #{e}\"\n      end\n\n      if authenticated?(body)\n        session[:auth_user] = username\n        session[:auth_host] = host\n        return \"Remote server responded with: #{body}.\" \\\n               \" Authenticated as #{username}@#{host}!\"\n      else\n        session[:auth_user] = nil\n        session[:auth_host] = nil\n        sleep(1) # prevent abuse\n        return \"Remote server responded with: #{body}.\" \\\n               \" Unable to authenticate as #{username}@#{host}.\"\n      end\n    end\n\n    def perform_authenticate(url, username, password)\n      $log.info(\"Sending request to #{url}\")\n      response = RestClient.post(url, {:password => password,\n                                       :username => username})\n      body = response.body\n\n      $log.info(\"Server responded with: #{body}\")\n      body\n    end\n\n    def authenticated?(body)\n      body =~ /[^\\w]AUTHENTICATED[^\\w]*$/\n    end\n  end\nend\n\ndef main\n  DomainAuthenticator::DomainAuthenticatorSrv.run!\nend\n\nif $0 == __FILE__\n  main\n  exit(0)\nend\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\udcac",
        "index": 6,
        "name": "Streamer",
        "port": 4567,
        "sources": [
            {
                "language": "ruby",
                "level": 6,
                "name": "server/srv.rb",
                "content": "#!/usr/bin/env ruby\nrequire 'rubygems'\nrequire 'bundler/setup'\n\nrequire 'rack/utils'\nrequire 'rack/csrf'\nrequire 'json'\nrequire 'sequel'\nrequire 'sinatra'\n\nmodule Streamer\n  PASSWORD = ENV['LEVEL6_PW'].strip\n\n  module DB\n    def self.db_file\n      'streamer.db'\n    end\n\n    def self.conn\n      @conn ||= Sequel.sqlite(db_file)\n    end\n\n    def self.safe_insert(table, key_values)\n      key_values.each do |key, value|\n        # Just in case people try to exfiltrate\n        # level07-password-holder's password\n        if value.kind_of?(String) &&\n            (value.include?('\"') || value.include?(\"'\"))\n          raise \"Value has unsafe characters\"\n        end\n      end\n\n      conn[table].insert(key_values)\n    end\n\n    def self.init\n      return if File.exists?(db_file)\n      File.umask(0066)\n\n      conn.create_table(:users) do\n        primary_key :id\n        String :username\n        String :password\n        Time :last_active\n      end\n\n      conn.create_table(:posts) do\n        primary_id :id\n        String :user\n        String :title\n        String :body\n        Time :time\n      end\n\n      conn[:users].insert(:username => 'level07-password-holder',\n        :password => Streamer::PASSWORD,\n        :last_active => Time.now.utc)\n\n      conn[:posts].insert(:user => 'level07-password-holder',\n        :title => 'Hello World',\n        :body => \"Welcome to Streamer, the most streamlined way of sharing\nupdates with your friends!\n\nOne great feature of Streamer is that no password resets are needed. I, for\nexample, have a very complicated password (including apostrophes, quotes, you\nname it!). But I remember it by clicking my name on the right-hand side and\nseeing what my password is.\n\nNote also that Streamer can run entirely within your corporate firewall. My\nmachine, for example, can only talk directly to the Streamer server itself!\",\n        :time => Time.now.utc)\n    end\n  end\n\n  class StreamerSrv < Sinatra::Base\n    set :environment, :production\n    enable :sessions\n    set :port, Integer(ENV['PORT'] || 4567)\n\n    # Use persistent entropy file\n    entropy_file = 'entropy.dat'\n    unless File.exists?(entropy_file)\n      File.open(entropy_file, 'w') do |f|\n        f.write(OpenSSL::Random.random_bytes(24))\n      end\n    end\n    set :session_secret, File.read(entropy_file)\n\n    use Rack::Csrf, :raise => true\n\n    helpers do\n      # Insert an hidden tag with the anti-CSRF token into your forms.\n      def csrf_tag\n        Rack::Csrf.csrf_tag(env)\n      end\n\n      # Return the anti-CSRF token\n      def csrf_token\n        Rack::Csrf.csrf_token(env)\n      end\n\n      # Return the field name which will be looked for in the requests.\n      def csrf_field\n        Rack::Csrf.csrf_field\n      end\n\n      include Rack::Utils\n      alias_method :h, :escape_html\n    end\n\n    def redirect(url)\n      super(url)\n    end\n\n    before do\n      @user = logged_in_user\n      update_last_active\n    end\n\n    def logged_in_user\n      if session[:user]\n        @username = session[:user]\n        @user = DB.conn[:users][:username => @username]\n      end\n    end\n\n    def update_last_active\n      return unless @user\n      DB.conn[:users].where(:username => @user[:username]).\n        update(:last_active => Time.now.utc)\n    end\n\n    def recent_posts\n      # Grab the 5 most recent posts\n      DB.conn[:posts].reverse_order(:time).limit(5).to_a.reverse\n    end\n\n    def registered_users\n      DB.conn[:users].reverse_order(:id)\n    end\n\n    def die(msg, view)\n      @error = msg\n      halt(erb(view))\n    end\n\n    get '/' do\n      if @user\n        @registered_users = registered_users\n        @posts = recent_posts\n\n        erb :home\n      else\n        erb :login\n      end\n    end\n\n    get '/register' do\n      erb :register\n    end\n\n    post '/register' do\n      username = params[:username]\n      password = params[:password]\n      unless username && password\n        die(\"Please specify both a username and a password.\", :register)\n      end\n\n      unless DB.conn[:users].where(:username => username).count == 0\n        die(\"This username is already registered. Try another one.\",\n            :register)\n      end\n\n      DB.safe_insert(:users,\n        :username => username,\n        :password => password,\n        :last_active => Time.now.utc\n        )\n      session[:user] = username\n      redirect '/'\n    end\n\n    get '/login' do\n      redirect '/'\n    end\n\n    post '/login' do\n      username = params[:username]\n      password = params[:password]\n      user = DB.conn[:users][:username => username, :password => password]\n      unless user\n        die('Could not authenticate. Perhaps you meant to register a new' \\\n            ' account? (See link below.)', :login)\n      end\n\n      session[:user] = user[:username]\n      redirect '/'\n    end\n\n    get '/logout' do\n      session.clear\n      redirect '/'\n    end\n\n    get '/user_info' do\n      @password = @user[:password]\n\n      erb :user_info\n    end\n\n    before '/ajax/*' do\n      halt(403, 'Must be logged in!') unless @user\n    end\n\n    get '/ajax/posts' do\n      recent_posts.to_json\n    end\n\n    post '/ajax/posts' do\n      msg = create_post\n      resp = {:response => msg}\n      resp.to_json\n    end\n\n    # Fallback if JS breaks\n    get '/posts' do\n      redirect '/'\n    end\n\n    post '/posts' do\n      create_post if @user\n      redirect '/'\n    end\n\n    def create_post\n      post_body = params[:body]\n      title = params[:title] || 'untitled'\n      if post_body\n        DB.safe_insert(:posts,\n          :user => @user[:username],\n          :title => title,\n          :body => post_body,\n          :time => Time.now.utc\n          )\n        'Successfully added the post!'\n      else\n        'No post body given!'\n      end\n    end\n  end\nend\n\ndef main\n  Streamer::DB.init\n  Streamer::StreamerSrv.run!\nend\n\nif $0 == __FILE__\n  main\n  exit(0)\nend\n"
            },
            {
                "language": "ruby",
                "level": 6,
                "name": "server/views/layout.erb",
                "content": "<!doctype html>\n<html>\n  <head>\n    <title>Streamer</title>\n    <script src='/js/jquery-1.8.0.min.js'></script>\n    <link rel='stylesheet' type='text/css'\n          href='/css/bootstrap-combined.min.css' />\n  </head>\n  <body>\n    <div class='navbar'>\n      <div class='navbar-inner'>\n        <div class='container'>\n          <a class='brand' href='/'>Streamer</a>\n          <% if @user %>\n            <ul class='nav pull-right'>\n              <li><a href='/logout'>Log Out</a></li>\n            </ul>\n          <% end %>\n        </div>\n      </div>\n    </div>\n    <div class='container'>\n<% if @error %>\n  <p>Error: <%= @error %></p>\n<% end %>\n<% if @success %>\n  <p>Success: <%= @success %></p>\n<% end %>\n\n      <%= yield %>\n    </div>\n  </body>\n</html>\n"
            },
            {
                "language": "ruby",
                "level": 6,
                "name": "server/views/login.erb",
                "content": "<div class='row'>\n  <div class='span12'>\n    <h3>Login</h3>\n\n    <br />\n\n    <p>\n      Sign into your Streamer account, and instantly start sharing updates\n      with your friends. If you don't have an account yet,\n      <a href='/register'>create one now</a>!\n    </p>\n\n    <br />\n\n    <form class='form-inline' action='/login'\n          method='post'>\n      <%= csrf_tag %>\n      <input class='input-medium' name='username' type='text'\n             placeholder='Username'/>\n      <input class='input-medium' name='password' type='password'\n             placeholder='Password'/>\n      <input class='btn btn-primary' type='submit' value='Sign In'/>\n    </form>\n  </div>\n</div>\n"
            },
            {
                "language": "ruby",
                "level": 6,
                "name": "server/views/register.erb",
                "content": "<div class='row'>\n  <div class='span12'>\n    <h3>Register for a Streamer account</h3>\n\n    <br />\n\n    <form class='form-horizontal' action='/register'\n          method='post'>\n      <%= csrf_tag %>\n      <fieldset>\n        <div class='control-group'>\n          <label class='control-label' for='username'>Username:</label>\n          <div class='controls'>\n            <input class='input-medium' name='username' id='username'\n                   type='text' placeholder='Username'/>\n          </div>\n        </div>\n        <div class='control-group'>\n          <label class='control-label' for='username'>Password:</label>\n          <div class='controls'>\n            <input class='input-medium' name='password' id='password'\n                   type='password' placeholder='Password'/>\n          </div>\n        </div>\n        <div class='form-actions'>\n          <input class='btn btn-primary' type='submit' value='Register'/>\n        </div>\n      </fieldset>\n    </form>\n  </div>\n</div>\n"
            },
            {
                "language": "ruby",
                "level": 6,
                "name": "server/views/user_info.erb",
                "content": "<div class='row'>\n  <div class='span12'>\n    <h3>User Information</h3>\n    <table class='table table-condensed'>\n      <tr>\n        <th>Username:</th>\n        <td><%= @username %></td>\n      </tr>\n      <tr>\n        <th>Password:</th>\n        <td><%= @password %></td>\n      </tr>\n    </table>\n  </div>\n</div>\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\ude81",
        "index": 7,
        "name": "WaffleCopter",
        "port": 9233,
        "sources": [
            {
                "language": "python",
                "level": 7,
                "name": "wafflecopter.py",
                "content": "#!/usr/bin/env python\nimport hashlib\nimport json\nimport logging\nimport os\nimport sys\nimport urllib.request, urllib.parse, urllib.error\nfrom functools import wraps\n\nimport bcrypt\nimport sqlite3\nfrom flask import Flask, session, request, redirect, render_template, g, abort\nfrom flask import make_response\n\nimport db\nimport settings\n\napp = Flask(__name__)\napp.config.from_object(settings)\napp.logger.addHandler(logging.StreamHandler(sys.stderr))\n\n\nif not os.path.exists(settings.entropy_file):\n    print('Entropy file not found. Have you run initialize_db.py?')\n\n# use persistent entropy file for secret_key\napp.secret_key = open(settings.entropy_file, 'rb').read()\n\nclass BadSignature(Exception):\n    pass\nclass BadRequest(Exception):\n    pass\n\ndef valid_user(user, passwd):\n    try:\n        row = g.db.select_one('users', {'name': user})\n    except db.NotFound:\n        print('Invalid user', repr(user))\n        return False\n    if bcrypt.hashpw(passwd, row['password']) == row['password']:\n        print('Valid user:', repr(user))\n        return row\n    else:\n        print('Invalid password for', repr(user))\n        return False\n\ndef log_in(user, row):\n    session['user'] = row\n    session['username'] = user\n\ndef require_authentication(func):\n    @wraps(func)\n    def newfunc(*args, **kwargs):\n        if 'user' not in session:\n            return redirect('/login')\n        return func(*args, **kwargs)\n    return newfunc\n\ndef json_response(obj, status_code=200):\n    text = json.dumps(obj) + '\\n'\n    resp = make_response(text, status_code)\n    resp.headers['content-type'] = 'application/json'\n    return resp\n\ndef json_error(message, status_code):\n    return json_response({'error': message}, status_code)\n\ndef log_api_request(user_id, path, body):\n    if isinstance(body, str):\n        # body is a string byte stream, but sqlite will think it's utf-8\n        # convert each character to unicode so it's unambiguous\n        body = ''.join(chr(ord(c)) for c in body)\n    g.db.insert('logs', {'user_id': user_id, 'path': path, 'body': body})\n\ndef get_logs(user_id):\n    return g.db.select('logs', {'user_id': user_id})\n\ndef get_waffles():\n    return g.db.select('waffles')\n\n@app.before_request\ndef before_request():\n    g.db = db.DB(settings.database)\n    g.cursor = g.db.cursor\n\n@app.teardown_request\ndef teardown_request(exception):\n    if hasattr(g, 'db'):\n        g.db.commit()\n        g.db.close()\n\n@app.route('/')\n@require_authentication\ndef index():\n    user = session['user']\n    waffles = get_waffles()\n    return render_template('index.html', user=user, waffles=waffles,\n                           endpoint=request.url_root)\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        user = request.form['username']\n        password = request.form['password']\n        row = valid_user(user, password)\n        if row:\n            log_in(user, row)\n            return redirect('/')\n        else:\n            error = 'Invalid username or password'\n\n    return render_template('login.html', error=error)\n\n@app.route('/logs/<int:id>')\n@require_authentication\ndef logs(id):\n    rows = get_logs(id)\n    return render_template('logs.html', logs=rows)\n\ndef verify_signature(user_id, sig, raw_params):\n    # get secret token for user_id\n    try:\n        row = g.db.select_one('users', {'id': user_id})\n    except db.NotFound:\n        raise BadSignature('no such user_id')\n    secret = str(row['secret'])\n\n    h = hashlib.sha1()\n    h.update(secret + raw_params)\n    print('computed signature', h.hexdigest(), 'for body', repr(raw_params))\n    if h.hexdigest() != sig:\n        raise BadSignature('signature does not match')\n    return True\n\ndef parse_params(raw_params):\n    pairs = raw_params.split('&')\n    params = {}\n    for pair in pairs:\n        key, val = pair.split('=')\n        key = urllib.parse.unquote_plus(key)\n        val = urllib.parse.unquote_plus(val)\n        params[key] = val\n    return params\n\ndef parse_post_body(body):\n    try:\n        raw_params, sig = body.strip('\\n').rsplit('|sig:', 1)\n    except ValueError:\n        raise BadRequest('Request must be of form params|sig:da39a3ee5e6b...')\n\n    return raw_params, sig\n\ndef process_order(params):\n    user = g.db.select_one('users', {'id': params['user_id']})\n\n    # collect query parameters\n    try:\n        waffle_name = params['waffle']\n    except KeyError:\n        return json_error('must specify waffle', 400)\n    try:\n        count = int(params['count'])\n    except (KeyError, ValueError):\n        return json_error('must specify count', 400)\n    try:\n        lat, long = float(params['lat']), float(params['long'])\n    except (KeyError, ValueError):\n        return json_error('where would you like your waffle today?', 400)\n\n    if count < 1:\n        return json_error('count must be >= 1', 400)\n\n    # get waffle info\n    try:\n        waffle = g.db.select_one('waffles', {'name': waffle_name})\n    except db.NotFound:\n        return json_error('no such waffle: %s' % waffle_name, 404)\n\n    # check premium status\n    if waffle['premium'] and not user['premium']:\n        return json_error('that waffle requires a premium subscription', 402)\n\n    # return results\n    plural = 's' if count > 1 else ''\n    msg = 'Great news: %d %s waffle%s will soon be flying your way!' \\\n        % (count, waffle_name, plural)\n    return json_response({'success': True, 'message': msg,\n                          'confirm_code': waffle['confirm']})\n\n@app.route('/orders', methods=['POST'])\ndef order():\n    # We need the original POST body in order to check the hash, so we use\n    # request.input_stream rather than request.form.\n    request.shallow = True\n    body = request.input_stream.read(\n        request.headers.get('content-length', type=int) or 0)\n\n    # parse POST body\n    try:\n        raw_params, sig = parse_post_body(body)\n    except BadRequest as e:\n        print('failed to parse', repr(body))\n        return json_error(e.message, 400)\n\n    print('raw_params:', repr(raw_params))\n\n    try:\n        params = parse_params(raw_params)\n    except ValueError:\n        raise BadRequest('Could not parse params')\n\n    print('sig:', repr(sig))\n\n    # look for user_id and signature\n    try:\n        user_id = params['user_id']\n    except KeyError:\n        print('user_id not provided')\n        return json_error('must provide user_id', 401)\n\n    # check that signature matches\n    try:\n        verify_signature(user_id, sig, raw_params)\n    except BadSignature as e:\n        return json_error('signature check failed: ' + e.message, 401)\n\n    # all OK -- process the order\n    log_api_request(params['user_id'], '/orders', body)\n    return process_order(params)\n\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', 9233))\n    app.run(host='0.0.0.0', port=port)\n\n"
            },
            {
                "language": "python",
                "level": 7,
                "name": "client.py",
                "content": "#!/usr/bin/env python\nimport hashlib\nimport json\nimport sys\nimport urllib.parse\n\nimport requests\n\nclass ClientError(Exception):\n    pass\n\nclass Client(object):\n    def __init__(self, endpoint, user_id, api_secret):\n        self.endpoint = endpoint\n        self.user_id = user_id\n        self.api_secret = api_secret\n\n    def order(self, waffle_name, coords, count=1):\n        \"\"\"Order one or more waffles.\"\"\"\n        params = {'waffle': waffle_name, 'count': count,\n                  'lat': coords[0], 'long': coords[1]}\n        return self.api_call('/orders', params)\n\n    def api_call(self, path, params, debug_response=False):\n        \"\"\"Make an API call with parameters to the specified path.\"\"\"\n        body = self._make_post(params)\n        resp = requests.post(self.endpoint + path, data=body)\n\n        # for debugging\n        if debug_response:\n            return resp\n\n        # try to decode response as json\n        data = None\n        if resp.headers['content-type'] == 'application/json':\n            try:\n                data = json.loads(resp.text)\n            except ValueError:\n                pass\n            else:\n                # raise error message if any\n                error = data.get('error')\n                if error:\n                    raise ClientError(error)\n\n        # raise error on non-200 status codes\n        resp.raise_for_status()\n\n        # return response data decoded from JSON or just response body\n        return data or resp.text\n\n    def _make_post(self, params):\n        params['user_id'] = self.user_id\n        body = urllib.parse.urlencode(params)\n\n        sig = self._signature(body)\n        body += '|sig:' + sig\n\n        return body\n\n    def _signature(self, message):\n        h = hashlib.sha1()\n        h.update((self.api_secret + message).encode('utf-8'))\n        return h.hexdigest()\n\nif __name__ == '__main__':\n    if len(sys.argv) != 7:\n        print('usage: client.py ENDPOINT USER_ID SECRET WAFFLE LAT LONG')\n        sys.exit(1)\n\n    c = Client(*sys.argv[1:4])\n    print(c.order(sys.argv[4], sys.argv[5:7]))\n"
            },
            {
                "language": "python",
                "level": 7,
                "name": "db.py",
                "content": "import os\nimport sqlite3\nimport sys\n\nclass NotFound(Exception):\n    pass\nclass ManyFound(Exception):\n    pass\n\n# for app.secret_key\ndef rewrite_entropy_file(path):\n    f = open(path, 'wb')\n    f.write(os.urandom(24))\n    f.close()\n\nclass DB(object):\n    def __init__(self, database):\n        self.conn = sqlite3.connect(database,\n                                    detect_types=sqlite3.PARSE_DECLTYPES)\n        self.conn.row_factory = sqlite3.Row\n        self.cursor = self.conn.cursor()\n        self.debug = False\n\n    def log(self, *args):\n        if self.debug:\n            for i in args:\n                sys.stderr.write(str(i))\n            sys.stderr.write('\\n')\n\n    def commit(self):\n        self.conn.commit()\n\n    def close(self):\n        self.cursor.close()\n        self.conn.close()\n\n    def select(self, table, where=None):\n        if where is None:\n            where = {}\n        self.do_select(table, where)\n        return map(dict, self.cursor.fetchall())\n\n    def select_one(self, table, where=None):\n        where = where or {}\n        self.do_select(table, where)\n\n        row = self.cursor.fetchone()\n        if row is None:\n            raise NotFound\n\n        if self.cursor.fetchone() is not None:\n            raise ManyFound\n\n        return dict(row)\n\n    def do_select(self, table, where=None):\n        where = where or {}\n        where_clause = ' AND '.join('%s=?' % key for key in where.keys())\n        values = where.values()\n        q = 'select * from ' + str(table)\n        if where_clause:\n            q += ' where ' + where_clause\n        self.log(q, '<==', values)\n        self.cursor.execute(q, tuple(values))\n\n    def insert(self, table, data):\n        cols = ', '.join(data.keys())\n        vals = data.values()\n        placeholders = ', '.join('?' for i in data)\n        q = 'insert into %s (%s) values (%s)' % (table, cols, placeholders)\n        self.log(q, '<==', vals)\n        self.cursor.execute(q, tuple(vals))\n        self.commit()\n        return self.cursor.rowcount\n"
            },
            {
                "language": "python",
                "level": 7,
                "name": "initialize_db.py",
                "content": "#!/usr/bin/env python\nimport sys\nfrom datetime import datetime\nfrom random import SystemRandom\n\nimport bcrypt\nimport sqlite3\n\nimport client\nimport db\nimport settings\n\nconn = db.DB(settings.database)\nconn.debug = True\nc = conn.cursor\n\ndb.rewrite_entropy_file(settings.entropy_file)\n\nrand = SystemRandom()\n\ndef rand_choice(alphabet, length):\n    return ''.join(rand.choice(alphabet) for i in range(length))\n\nalphanum = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\ndef rand_alnum(length):\n    return rand_choice(alphanum, length)\n\ndef main(level_password):\n    create_tables()\n    add_users()\n    add_waffles(level_password)\n    add_logs()\n\ndef add_users():\n    add_user(1, 'larry', rand_alnum(16), 1)\n    add_user(2, 'randall', rand_alnum(16), 1)\n    add_user(3, 'alice', rand_alnum(16), 0)\n    add_user(4, 'bob', rand_alnum(16), 0)\n    add_user(5, 'ctf', 'password', 0)\n\ndef add_waffles(level_password):\n    add_waffle('liege', 1, level_password)\n    add_waffle('dream', 1, rand_alnum(14))\n    add_waffle('veritaffle', 0, rand_alnum(14))\n    add_waffle('chicken', 1, rand_alnum(14))\n    add_waffle('belgian', 0, rand_alnum(14))\n    add_waffle('brussels', 0, rand_alnum(14))\n    add_waffle('eggo', 0, rand_alnum(14))\n\ndef add_logs():\n    gen_log(1, '/orders', {'waffle': 'eggo', 'count': 10,\n                           'lat': 37.351, 'long': -119.827})\n    gen_log(1, '/orders', {'waffle': 'chicken', 'count': 2,\n                           'lat': 37.351, 'long': -119.827})\n    gen_log(2, '/orders', {'waffle': 'dream', 'count': 2,\n                           'lat': 42.39561, 'long': -71.13051},\n            date=datetime(2007, 9, 23, 14, 38, 00))\n    gen_log(3, '/orders', {'waffle': 'veritaffle', 'count': 1,\n                           'lat': 42.376, 'long': -71.116})\n\ndef create_tables():\n    c.execute('drop table if exists users')\n    c.execute('''\n    CREATE TABLE users(\n    id int not null primary key,\n    name varchar(255) not null,\n    password varchar(255) not null,\n    premium int not null,\n    secret varchar(255) not null,\n    unique (name)\n    )\n    ''')\n\n    c.execute('drop table if exists waffles')\n    c.execute('''\n    CREATE TABLE waffles(\n    name varchar(255) not null primary key,\n    premium int not null,\n    confirm varchar(255) not null\n    )\n    ''')\n\n    c.execute('drop table if exists logs')\n    c.execute('''\n    CREATE TABLE logs(\n    user_id int not null,\n    path varchar(255) not null,\n    body text not null,\n    date timestamp not null default current_timestamp\n    )\n    ''')\n    c.execute('create index user_id on logs (user_id)')\n    c.execute('create index date on logs (date)')\n\ndef add_user(uid, username, password, premium):\n    hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(10))\n    secret = rand_alnum(14)\n    data = {'id': uid, 'name': username, 'password': hashed.decode('utf-8'),\n            'premium': premium, 'secret': secret}\n    conn.insert('users', data)\n\ndef get_user(uid):\n    return conn.select_one('users', {'id': uid})\n\ndef add_waffle(name, premium, confirm):\n    data = {'name': name, 'premium': premium, 'confirm': confirm}\n    conn.insert('waffles', data)\n\ndef gen_log(user_id, path, params, date=None):\n    user = get_user(user_id)\n\n    # generate signature using client library\n    cl = client.Client(None, user_id, user['secret'])\n    body = cl._make_post(params)\n\n    # prepare data for insert\n    data = {'user_id': user_id, 'path': path, 'body': body}\n\n    if date:\n        data['date'] = date\n\n    conn.insert('logs', data)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print('usage: initialize_db.py LEVEL_PASSWORD')\n        sys.exit(1)\n\n    main(sys.argv[1])\n"
            },
            {
                "language": "python",
                "level": 7,
                "name": "settings.py",
                "content": "import os\n\nDEBUG = False\ndatabase = os.path.join(os.path.dirname(__file__), 'wafflecopter.db')\nentropy_file = os.path.join(os.path.dirname(__file__), 'entropy.dat')\n\ntry:\n    from local_settings import *\nexcept ImportError:\n    pass\n"
            },
            {
                "language": "html",
                "level": 7,
                "name": "templates/index.html",
                "content": "<!doctype html>\n<html>\n  <head>\n    <title>WaffleCopter</title>\n    <style>\n      a {\n        color: black;\n      }\n      a:hover {\n        color: blue;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>WaffleCopter [beta]</h1>\n    <p>Welcome, {{user['name']}}!</p>\n    <h3>Your API credentials</h3>\n    <ul>\n      <li><strong>endpoint:</strong> <code>{{ endpoint }}</code></li>\n      <li><strong>user_id:</strong> <code>{{ user['id'] }}</code></li>\n      <li><strong>secret:</strong> <code>{{ user['secret'] }}</code></li>\n    </ul>\n    <h3>Available waffles</h3>\n    <ul>\n      {% for waffle in waffles %}\n      <li>\n        {{ waffle['name'] }}{% if waffle['premium'] %} (premium){% endif %}\n      </li>\n      {% endfor %}\n    </ul>\n    <h3><a href=\"./logs/{{ user['id'] }}\">API Request logs</a></h3>\n  </body>\n</html>\n"
            },
            {
                "language": "html",
                "level": 7,
                "name": "templates/login.html",
                "content": "<!doctype html>\n<html>\n  <head>\n    <title>WaffleCopter - Login</title>\n  </head>\n  <body>\n    <h1>WaffleCopter [beta]</h1>\n    {% if error %}\n    <p style=\"color: red\">{{ error }}</p>\n    {% endif %}\n    <form action=\"./login\" method=\"post\">\n      <table>\n        <tr>\n          <td>username:</td><td><input type=\"text\" name=\"username\" /></td>\n        </tr>\n        <tr>\n          <td>password:</td><td><input type=\"password\" name=\"password\" /></td>\n        </tr>\n        <tr>\n          <td colspan=2><input type=\"submit\" value=\"log in\" /></td>\n        </tr>\n      </table>\n    </form>\n  </body>\n</html>\n"
            },
            {
                "language": "html",
                "level": 7,
                "name": "templates/logs.html",
                "content": "<!doctype html>\n<html>\n  <head>\n    <title>WaffleCopter - Logs</title>\n    <style type=\"text/css\">\n      table#logs {\n        border-collapse: collapse;\n      }\n      #logs td,th {\n        border: 1px solid #CCC;\n        padding: 5px;\n      }\n      #home {\n        text-decoration: none;\n        color: #000;\n      }\n      #home:hover {\n        color: blue;\n      }\n    </style>\n  </head>\n  <body>\n    <h1><a id=home href=\"../\">WaffleCopter [beta]</a></h1>\n    <h3>API Request Logs</h3>\n    <table id=logs>\n      <tr><th>date</th><th>path</th><th>body</th></tr>\n      {% for log in logs %}\n      <tr>\n        <td>{{ log['date'].strftime('%F %R:%S') }}</td>\n        <td>{{ log['path'] }}</td>\n        <td><code>{{ log['body'].encode('unicode-escape') }}</code></td>\n      </tr>\n      {% endfor %}\n    </table>\n  </body>\n</html>\n"
            }
        ]
    },
    {
        "emoji": "\ud83d\udd11",
        "index": 8,
        "name": "PasswordDB",
        "port": 4000,
        "sources": [
            {
                "language": "python",
                "level": 8,
                "name": "primary_server",
                "content": "#!/usr/bin/env python\nimport fcntl\nimport logging\nimport json\nimport optparse\nimport sys\nimport time\nimport traceback\n\nfrom twisted.internet import reactor\n\n# Local project\nimport common\n\nlogger = logging.getLogger('password_db')\nlogger.addHandler(logging.StreamHandler(sys.stderr))\n\n\nclass PrimaryProcessor(common.PayloadProcessor):\n    def __init__(self, request, chunk_servers):\n        super(PrimaryProcessor, self).__init__(request)\n        self.chunk_servers = chunk_servers\n\n    def process(self, data):\n        Shield.registerLocker()\n\n        password = self.getArg(data, 'password')\n        webhooks = self.getArg(data, 'webhooks')\n\n        self.start_time = time.time()\n\n        self.remaining_chunk_servers = self.chunk_servers[:]\n        self.remaining_chunks = self.chunkPassword(password)\n\n        self.webhooks = [common.parseHost(webhook) for webhook in webhooks]\n\n        self.checkNext()\n\n    def checkNext(self):\n        assert(len(self.remaining_chunks) == len(self.remaining_chunk_servers))\n\n        if not self.remaining_chunk_servers:\n            self.sendResult(True)\n            return\n\n        next_chunk_server = self.remaining_chunk_servers.pop(0)\n        next_chunk = self.remaining_chunks.pop(0)\n\n        self.log_info('Making request to chunk server %r'\n                      ' (remaining chunk servers: %r)' %\n                      (next_chunk_server, self.remaining_chunk_servers))\n\n        common.makeRequest(next_chunk_server,\n                           {'password_chunk' : next_chunk},\n                           self.nextServerCallback,\n                           self.nextServerErrback)\n\n    def nextServerCallback(self, data):\n        parsed_data = json.loads(data)\n        # Chunk was wrong!\n        if not parsed_data['success']:\n            # Defend against timing attacks\n            remaining_time = self.expectedRemainingTime()\n            self.log_info('Going to wait %s seconds before responding' %\n                          remaining_time)\n            reactor.callLater(remaining_time, self.sendResult, False)\n            return\n\n        self.checkNext()\n\n    def expectedRemainingTime(self):\n        assert(len(self.chunk_servers) > len(self.remaining_chunk_servers))\n        elapsed_time = time.time() - self.start_time\n        ratio_remaining_to_elapsed = (len(self.remaining_chunk_servers) * 1.0\n            / (len(self.chunk_servers) - len(self.remaining_chunk_servers)))\n        return ratio_remaining_to_elapsed * elapsed_time\n\n    def nextServerErrback(self, address_spec, error):\n        backtrace = traceback.format_exc(error)\n        self.log_error('Error while connecting to chunk server %r: %s (%r)' %\n                       (address_spec, error, backtrace))\n        self.respondWithMessage('Error! This should never happen in '\n                                'production, but it seems that it did. Contact'\n                                ' us at ctf@stripe.com to let us know.')\n\n    def sendResult(self, success):\n        result = {'success': success}\n        self.respond(result)\n        for webhook in self.webhooks:\n            self.sendWebhook(webhook, result)\n\n    def sendWebhook(self, webhook_host_spec, result):\n        self.log_info('Sending webhook to %r: %s' %\n                      (webhook_host_spec, result))\n        common.makeRequest(webhook_host_spec, result, self.sendWebhookCallback,\n                           self.sendWebhookErrback)\n\n    def sendWebhookCallback(self, data):\n        # Too late to do anything here\n        pass\n\n    def sendWebhookErrback(self, address_spec, error):\n        backtrace = traceback.format_exc(error)\n        self.log_error('Error while connecting to webhook server %r: %s (%r)' %\n                       (address_spec, error, backtrace))\n\n    def chunkPassword(self, password):\n        return common.chunkPassword(len(self.chunk_servers), password, self)\n\nclass Shield(object):\n    # Ensure equitable distribution of load among many PasswordDB\n    # instances on a single server. (Typically servers come with many\n    # PasswordDB instances.)\n    @classmethod\n    def registerLocker(self):\n        if self.has_lock:\n            return\n\n        self.acquireLock()\n        reactor.callLater(self.lock_period, self.releaseLock)\n\n    @classmethod\n    def acquireLock(self):\n        logger.info('Acquiring lock')\n        fcntl.flock(self.lockfile, fcntl.LOCK_EX)\n        self.has_lock = True\n\n    @classmethod\n    def releaseLock(self):\n        logger.info('Releasing lock')\n        fcntl.flock(self.lockfile, fcntl.LOCK_UN)\n        self.has_lock = False\n\n    @classmethod\n    def openLockfile(self, path):\n        self.lock_period = 0.250\n        self.has_lock = False\n        self.lockfile = open(path, 'w')\n\ndef main():\n    usage = \"\"\"\n%prog -c CHUNK_SERVER [-c CHUNK_SERVER ...] [-q ...] -l /path/to/lockfile PRIMARY_SERVER\n\nCHUNK_SERVER:\n    A chunk server to spin up as <chunk_host:chunk_port>\n\nPRIMARY_SERVER:\n    Either pass a host:port pair <primary_host:primary_port> or pass a\n    unix:-prefixed path for it to listen on a UNIX socket\n    <unix:/path/to/socket> (useful for running under FastCGI).\n\"\"\"\n    parser = optparse.OptionParser(usage)\n    parser.add_option('-q', '--quiet', help='Quietness of debugging output.',\n                      dest='quiet', action='count', default=0)\n    parser.add_option('-c', '--chunk-servers',\n                      help='Add a chunk server to spin up',\n                      dest='chunk_servers', action='append', default=[])\n    parser.add_option('-l', '--lock-file',\n                      help='Path to lockfile',\n                      dest='lockfile')\n    opts, args = parser.parse_args()\n    if not opts.quiet:\n        logger.setLevel(logging.DEBUG)\n    elif opts.quiet == 1:\n        logger.setLevel(logging.INFO)\n    elif opts.quiet >= 2:\n        logger.setLevel(logging.WARN)\n\n    if len(args) != 1:\n        parser.print_usage()\n        return 1\n\n    if not opts.chunk_servers:\n        parser.print_usage()\n        return 1\n\n    if not opts.lockfile:\n        parser.print_usage()\n        return 1\n\n    Shield.openLockfile(opts.lockfile)\n\n    chunk_servers = [common.parseHost(spec) for spec in opts.chunk_servers]\n\n    server = common.HTTPServer(PrimaryProcessor, chunk_servers)\n\n    spec = args[0]\n    if common.isUnix(spec):\n        path = common.parseUnix(spec)\n        common.listenUNIX(path, server)\n    else:\n        address_spec = common.parseHost(args[0])\n        common.listenTCP(address_spec, server)\n\n    reactor.run()\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
            },
            {
                "language": "python",
                "level": 8,
                "name": "password_db_launcher",
                "content": "#!/usr/bin/env python\nimport atexit\nimport logging\nimport optparse\nimport os\nimport os.path\nimport random\nimport re\nimport signal\nimport socket\nimport subprocess\nimport sys\nimport time\n\nimport common\n\nlogger = logging.getLogger('password_db')\nlogger.addHandler(logging.StreamHandler(sys.stderr))\n\nprocesses = []\n\ndef launch(script, *args):\n    path = os.path.join(os.path.dirname(__file__), script)\n    args = [path] + list(args)\n    launched = subprocess.Popen(args)\n    logger.info('Launched %r (pid %d)' % (args, launched.pid))\n    processes.append(launched)\n    return launched\n\ndef gracefullyExit(signum, frame):\n    exit(1)\n\ndef nukeChildren():\n    logger.info('Killing all remaining children')\n    for process in processes:\n        try:\n            os.kill(process.pid, signal.SIGTERM)\n        except OSError:\n            pass\n        else:\n            logger.info('Killed child %s' % process.pid)\n\ndef waitChildren():\n    os.wait()\n\ndef passwordSpecToPassword(password_spec):\n    if password_spec and password_spec[0] == '@':\n        password_file = password_spec[1:]\n        logger.info('Reading password from %s' % password_file)\n        return open(password_file).read()\n    else:\n        return password_spec\n\ndef validatePassword(password):\n    if not re.search('^\\d{12}$', password):\n        raise ValueError(\"Invalid password! The Flag is a 12-digit number.\")\n\ndef socket_exists(host, port):\n    logger.info('Checking whether %s:%s is reachable' % (host, port))\n    try:\n        socket.create_connection([host, port])\n    except socket.error:\n        return False\n    else:\n        return True\n\ndef find_open_port(base_port):\n    while socket_exists('127.0.0.1', base_port):\n        base_port += 1\n    return base_port\n\ndef wait_until(condition, *args):\n    for i in range(10):\n        if condition(*args):\n            return\n        else:\n            logger.info('Condition not yet true, waiting 0.35 seconds'\n                        ' (try %s/%s)' % (i+1, 10))\n            time.sleep(0.35)\n    raise RuntimeError('Timed out waiting for condition')\n\ndef main():\n    \"\"\"\n    Spins up a secure configuration of PasswordDB:\n\n    - Uses 4 chunk servers\n    - Validates that the Flag itself looks correct\n    \"\"\"\n\n    usage = \"\"\"%prog [-q ...] <password_spec> <primary_address>\n\nprimary_address should be of the form 'host:port' or 'unix:/path/to/socket'\"\"\"\n    parser = optparse.OptionParser(usage)\n    parser.add_option('-q', '--quiet', help='Quietness of debugging output.',\n                      dest='quiet', action='count', default=0)\n    opts, args = parser.parse_args()\n    if not opts.quiet:\n        logger.setLevel(logging.DEBUG)\n    elif opts.quiet == 1:\n        logger.setLevel(logging.INFO)\n    elif opts.quiet >= 2:\n        logger.setLevel(logging.WARN)\n\n    if len(args) != 2:\n        parser.print_usage()\n        return 1\n\n    password_spec = args[0]\n    primary_host_spec = args[1]\n\n    signal.signal(signal.SIGTERM, gracefullyExit)\n    atexit.register(nukeChildren)\n\n    password = passwordSpecToPassword(password_spec)\n    validatePassword(password)\n\n    chunk_count = 4\n    chunks = common.chunkPassword(chunk_count, password)\n\n    base_port = random.randint(1024, 20000)\n    chunk_hosts = []\n    for i in range(chunk_count):\n        port = find_open_port(base_port)\n        base_port = port + 1\n        chunk_hosts.append(['127.0.0.1', port])\n\n    for host_port, password_chunk in zip(chunk_hosts, chunks):\n        host, port = host_port\n        launch('chunk_server', '%s:%s' % (host, port), password_chunk)\n\n    time.sleep(0.35)\n\n    # Make sure everything is booted before starting the primary server\n    for host_port in chunk_hosts:\n        host, port = host_port\n        wait_until(socket_exists, host, port)\n\n    args = []\n    args.append('-l')\n    args.append('/tmp/primary.lock')\n    for host, port in chunk_hosts:\n        args.append('-c')\n        args.append('%s:%s' % (host, port))\n    args.append(primary_host_spec)\n    launch('primary_server', *args)\n\n    waitChildren()\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
            },
            {
                "language": "python",
                "level": 8,
                "name": "common.py",
                "content": "import atexit\nimport json\nimport logging\nimport os\n\nfrom twisted.internet import reactor, protocol\nfrom twisted.protocols import basic\n\nfrom twisted.web import server, resource, client\n\nlogger = logging.getLogger('password_db.common')\n\n\nclass Halt(Exception):\n    pass\n\n\nclass HTTPServer(resource.Resource):\n    isLeaf = True\n\n    def __init__(self, processor, args):\n        self.processor = processor\n        self.args = args\n\n    def render_GET(self, request):\n        return ('{\"success\": false, \"message\": \"GET not supported.'\n                ' Try POSTing instead.\"}\\n')\n\n    def render_POST(self, request):\n        processor_instance = self.processor(request, self.args)\n        processor_instance.processRaw()\n        return server.NOT_DONE_YET\n\nclass PayloadProcessor:\n    request_count = 0\n\n    def __init__(self, request):\n        PayloadProcessor.request_count += 1\n        self.request_id = PayloadProcessor.request_count\n        self.request = request\n\n    def processRaw(self):\n        raw_data = self.request.content.read()\n        self.log_info('Received payload: %r', raw_data)\n\n        try:\n            parsed = json.loads(raw_data)\n        except ValueError as e:\n            self.respondWithMessage('Could not parse message: %s' % e)\n            return\n\n        try:\n            self.process(parsed)\n        except Halt:\n            pass\n\n    # API method\n    def process(self, data):\n        raise NotImplementedError\n\n    # Utility methods\n    def getArg(self, data, name):\n        try:\n            return data[name]\n        except KeyError:\n            self.respondWithMessage('Missing required param: %s' % name)\n            raise Halt()\n\n    def respondWithMessage(self, message):\n        response = {\n            'success' : False,\n            'message' : message\n            }\n        self.respond(response)\n\n    def respond(self, response):\n        if self.request.notifyFinish():\n            self.log_error(\"Request already finished!\")\n        formatted = json.dumps(response) + '\\n'\n        self.log_info('Responding with: %r', formatted)\n        self.request.write(formatted)\n        self.request.finish()\n\n    def log_info(self, *args):\n        self.log('info', *args)\n\n    def log_error(self, *args):\n        self.log('error', *args)\n\n    def log(self, level, msg, *args):\n        # Make this should actually be handled by a formatter.\n        client = self.request.client\n        try:\n            host = client.host\n            port = client.port\n        except AttributeError:\n            prefix = '[%r:%d] '  % (client, self.request_id)\n        else:\n            prefix = '[%s:%d:%d] '  % (host, port, self.request_id)\n        method = getattr(logger, level)\n        interpolated = msg % args\n        method(prefix + interpolated)\n\ndef chunkPassword(chunk_count, password, request=None):\n    # Equivalent to ceil(password_length / chunk_count)\n    chunk_size = (len(password) + chunk_count - 1) // chunk_count\n\n    chunks = []\n    for i in range(0, len(password), chunk_size):\n        chunks.append(password[i:i+chunk_size])\n\n    while len(chunks) < chunk_count:\n        chunks.append('')\n\n    msg = 'Split length %d password into %d chunks of size about %d: %r'\n    args = [len(password), chunk_count, chunk_size, chunks]\n    if request:\n        request.log_info(msg, *args)\n    else:\n        logger.info(msg, *args)\n\n    return chunks\n\ndef isUnix(spec):\n    return spec.startswith('unix:')\n\ndef parseHost(host):\n    host, port = host.split(':')\n    port = int(port)\n    return host, port\n\ndef parseUnix(unix):\n    path = unix[len('unix:'):]\n    return path\n\ndef makeRequest(address_spec, data, callback, errback):\n    # Change the signature of the errback\n    def wrapper(error):\n        errback(address_spec, error)\n\n    host, port = address_spec\n    factory = client.HTTPClientFactory(\n        '/',\n        agent='PasswordChunker',\n        method='POST',\n        postdata=json.dumps(data)\n    )\n    factory.deferred.addCallback(callback)\n    factory.deferred.addErrback(wrapper)\n    reactor.connectTCP(host, port, factory)\n\ndef listenTCP(address_spec, http_server):\n    host, port = address_spec\n    site = server.Site(http_server)\n    reactor.listenTCP(port, site, 50, host)\n\ndef cleanupSocket(path):\n    try:\n        os.remove(path)\n    except OSError:\n        pass\n\ndef listenUNIX(path, http_server):\n    site = server.Site(http_server)\n    reactor.listenUNIX(path, site, 50)\n    atexit.register(cleanupSocket, path)\n"
            },
            {
                "language": "python",
                "level": 8,
                "name": "chunk_server",
                "content": "#!/usr/bin/env python\nimport logging\nimport optparse\nimport sys\n\nfrom twisted.internet import reactor\n\n# Local project\nimport common\n\nlogger = logging.getLogger('password_db')\nlogger.addHandler(logging.StreamHandler(sys.stderr))\n\nclass ChunkProcessor(common.PayloadProcessor):\n    def __init__(self, request, password_chunk):\n        super(ChunkProcessor, self).__init__(request)\n        self.password_chunk = password_chunk\n\n    def process(self, data):\n        chunk = self.getArg(data, 'password_chunk')\n        success = chunk == self.password_chunk\n        self.respond({\n                'success' : success\n                })\n\ndef main():\n    usage = \"\"\"%prog [-q ...] <host:port> <password_chunk>\"\"\"\n    parser = optparse.OptionParser(usage)\n    parser.add_option('-q', '--quiet', help='Quietness of debugging output.',\n                      dest='quiet', action='count', default=0)\n    opts, args = parser.parse_args()\n    if not opts.quiet:\n        logger.setLevel(logging.DEBUG)\n    elif opts.quiet == 1:\n        logger.setLevel(logging.INFO)\n    elif opts.quiet >= 2:\n        logger.setLevel(logging.WARN)\n\n    if len(args) != 2:\n        parser.print_usage()\n        return 1\n\n    address_spec = common.parseHost(args[0])\n    password_chunk = args[1]\n\n    server = common.HTTPServer(ChunkProcessor, password_chunk)\n    common.listenTCP(address_spec, server)\n    reactor.run()\n\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
            }
        ]
    }
]
